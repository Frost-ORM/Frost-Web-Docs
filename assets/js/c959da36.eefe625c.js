"use strict";(self.webpackChunkfrost_web_doc=self.webpackChunkfrost_web_doc||[]).push([[5011],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>f});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var p=a.createContext({}),s=function(e){var t=a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=s(e.components);return a.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),m=s(n),f=r,y=m["".concat(p,".").concat(f)]||m[f]||c[f]||o;return n?a.createElement(y,i(i({ref:t},d),{},{components:n})):a.createElement(y,i({ref:t},d))}));function f(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var s=2;s<o;s++)i[s]=n[s];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1135:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>l,toc:()=>s});var a=n(7462),r=(n(7294),n(3905));const o={},i=void 0,l={unversionedId:"api/types/RelationOptions",id:"version-1.0.3/api/types/RelationOptions",title:"RelationOptions",description:"@frost/frost-web / Exports / RelationOptions",source:"@site/versioned_docs/version-1.0.3/api/types/RelationOptions.md",sourceDirName:"api/types",slug:"/api/types/RelationOptions",permalink:"/frost-web-docs/1.0.3/api/types/RelationOptions",draft:!1,tags:[],version:"1.0.3",frontMatter:{},sidebar:"apiSidebar",previous:{title:"ListenToNestedChanges",permalink:"/frost-web-docs/1.0.3/api/types/ListenToNestedChanges"},next:{title:"SerializeOptions",permalink:"/frost-web-docs/1.0.3/api/types/SerializeOptions"}},p={},s=[{value:"Type declaration",id:"type-declaration",level:4}],d={toc:s};function c(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"/frost-web-docs/1.0.3/api/modules"},"@frost/frost-web")," / ",(0,r.kt)("a",{parentName:"p",href:"/frost-web-docs/1.0.3/api/modules"},"Exports")," / RelationOptions"),(0,r.kt)("h1",{id:"type-alias-relationoptions"},"Type alias: RelationOptions"),(0,r.kt)("p",null,"\u01ac ",(0,r.kt)("strong",{parentName:"p"},"RelationOptions"),": ",(0,r.kt)("inlineCode",{parentName:"p"},"Object")),(0,r.kt)("p",null,"Interface of the options that are passed to the ",(0,r.kt)("a",{parentName:"p",href:"/frost-web-docs/1.0.3/api/decorators/Relation"},"Relation")," Decorator"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"Example"))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},'class A extends FrostObject{\n...\n@Relation({\n name: "AB",\nrelation: RelationTypes.ONE_TO_MANY,\ntype: () => B,\n})\nb?:() => B[]\n\n...\n}\n')),(0,r.kt)("h4",{id:"type-declaration"},"Type declaration"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:"left"},"Name"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Type"),(0,r.kt)("th",{parentName:"tr",align:"left"},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"master?")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"boolean")),(0,r.kt)("td",{parentName:"tr",align:"left"},"In Case of Asymmetric (One to Many) relation, to decide which side is the one and which side is the many.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"name")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"string")),(0,r.kt)("td",{parentName:"tr",align:"left"},"the name of the relation, It should be the same on both sides")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"reference?")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"string")),(0,r.kt)("td",{parentName:"tr",align:"left"},"(unrecommended) the name of the local field that contains the id that the relations is based on. this is optional and actually it's recommend not to use unless needed. ",(0,r.kt)("br",null)," Frost by default handles the relations and the stored keys that connect the nodes, but if you need access to these keys you could use the methods (",(0,r.kt)("a",{parentName:"td",href:"/frost-web-docs/1.0.3/api/classes/FrostObject#getconnectedkeys-1"},"getConnectedKeys"),", FrostObject.getAllConnectedKeyss or you could set the reference on the relation.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"relation?")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("a",{parentName:"td",href:"/frost-web-docs/1.0.3/api/enums/RelationTypes"},(0,r.kt)("inlineCode",{parentName:"a"},"RelationTypes"))),(0,r.kt)("td",{parentName:"tr",align:"left"},"the relation type ","[One to One, One to Many, Many to Many]")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"type")),(0,r.kt)("td",{parentName:"tr",align:"left"},(0,r.kt)("inlineCode",{parentName:"td"},"any")),(0,r.kt)("td",{parentName:"tr",align:"left"},"the data type of the local property that the relation is defined on, (ignore array brackets in case of many-to-many/ one-to-many).",(0,r.kt)("br",null)," this is needed because of some limitations in the decorators in TS/JS.",(0,r.kt)("br",null)," also it needs to be a function that returns the type to avoid cyclic dependency ",(0,r.kt)("inlineCode",{parentName:"td"},"(()=>Type)"),"  check the example")))))}c.isMDXComponent=!0}}]);