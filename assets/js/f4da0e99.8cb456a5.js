"use strict";(self.webpackChunkfrost_web_doc=self.webpackChunkfrost_web_doc||[]).push([[5380],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=a.createContext({}),m=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=m(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),u=m(n),h=i,k=u["".concat(s,".").concat(h)]||u[h]||d[h]||r;return n?a.createElement(k,l(l({ref:t},p),{},{components:n})):a.createElement(k,l({ref:t},p))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,l=new Array(r);l[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var m=2;m<r;m++)l[m]=n[m];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2193:(e,t,n)=>{n.r(t),n.d(t,{contentTitle:()=>l,default:()=>p,frontMatter:()=>r,metadata:()=>o,toc:()=>s});var a=n(7462),i=(n(7294),n(3905));const r={toc_min_heading_level:2,toc_max_heading_level:6},l="Frost Schema Language (FSL)",o={type:"mdx",permalink:"/frost-web-docs/frost-schema-language",source:"@site/src/pages/frost-schema-language.mdx",title:"Frost Schema Language (FSL)",description:"Structure",frontMatter:{toc_min_heading_level:2,toc_max_heading_level:6}},s=[{value:"Structure",id:"structure",level:2},{value:"Syntax",id:"syntax",level:3},{value:"Keywords",id:"keywords",level:4},{value:"Comments",id:"comments",level:4},{value:"Pragmas",id:"pragmas",level:4},{value:"Modifiers",id:"modifiers",level:4},{value:"Arguments",id:"arguments",level:4},{value:"Primitive Values",id:"primitive-values",level:4},{value:"Allowed Data types",id:"allowed-data-types",level:4},{value:"Defintions",id:"defintions",level:3},{value:"Defining Enums",id:"defining-enums",level:4},{value:"Defining Types",id:"defining-types",level:4},{value:"Defining Models",id:"defining-models",level:4},{value:"<code>node</code> Pragma",id:"node-pragma",level:5},{value:"<code>Relation</code> Modifier",id:"relation-modifier",level:5},{value:"Syntax Highlighting",id:"syntax-highlighting",level:2},{value:"Vscode",id:"vscode",level:3}],m={toc:s};function p(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,a.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"frost-schema-language-fsl"},"Frost Schema Language (FSL)"),(0,i.kt)("h2",{id:"structure"},"Structure"),(0,i.kt)("h3",{id:"syntax"},"Syntax"),(0,i.kt)("p",null,"In this section we'll define the essential parts that comprise the FSL syntax"),(0,i.kt)("h4",{id:"keywords"},"Keywords"),(0,i.kt)("p",null,"In FSL we have three main keywords"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"model")," used to ",(0,i.kt)("a",{parentName:"li",href:"#defining-models"},"define a data model"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"enum")," used to ",(0,i.kt)("a",{parentName:"li",href:"#defining-enums"},"define an enum"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"type")," used to ",(0,i.kt)("a",{parentName:"li",href:"#defining-types"},"define a data type (struct)"),".")),(0,i.kt)("h4",{id:"comments"},"Comments"),(0,i.kt)("p",null,"FSL supports double-slash single line comments, you can write comments at the beging and end of each line or in seperate lines."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-prisma"},"// This is a comment\n\nmodel A { // This is a comment\n  // This is a comment\n  ...\n\n}\n// This is a comment\n\ntype Data { // This is a comment\n  // This is a comment\n  ...\n\n} // This is a comment\n")),(0,i.kt)("h4",{id:"pragmas"},"Pragmas"),(0,i.kt)("p",null,"Pragma in FSL are used to declare or modify the behaviour in a scope (block, global).\nPragmas are written in the following pattern ",(0,i.kt)("inlineCode",{parentName:"p"},"@@pragma_name(pragma_arguments)"),". (pragma ",(0,i.kt)("a",{parentName:"p",href:"#arguments"},"arguments")," can be either named or positional or a combination of both)"),(0,i.kt)("p",null,"an example of pragmas is the ",(0,i.kt)("a",{parentName:"p",href:"#node-pragma"},(0,i.kt)("inlineCode",{parentName:"a"},"node")," pragma")),(0,i.kt)("h4",{id:"modifiers"},"Modifiers"),(0,i.kt)("p",null,"Modifiers in FSL are used to modify the behaviour of a statement or add certain metadata .\nModifiers are written in the following pattern ",(0,i.kt)("inlineCode",{parentName:"p"},"@modifier_name(modifier_arguments)"),". (modifier ",(0,i.kt)("a",{parentName:"p",href:"#arguments"},"arguments")," can be either named or positional or a combination of both)"),(0,i.kt)("p",null,"an example of pragmas is the ",(0,i.kt)("a",{parentName:"p",href:"#relation-modifier"},(0,i.kt)("inlineCode",{parentName:"a"},"Relation")," modifier")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Modfiers and Pragmas are written in a similar pattern but Modfiers start with a single annotation while pragmas start with two.\nModifiers names are in Pascal Case while Pragmas names are in snake_case")),(0,i.kt)("h4",{id:"arguments"},"Arguments"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("em",{parentName:"strong"},"Positional Arguments")),": comma-seperated values, for example",(0,i.kt)("inlineCode",{parentName:"li"},"(1,'a',true)"),". Position is important hence the name so ",(0,i.kt)("inlineCode",{parentName:"li"},"(1,'a',true)")," is not the same as ",(0,i.kt)("inlineCode",{parentName:"li"},"('a',true,1)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("em",{parentName:"strong"},"Named Arguments")),": each argument is written in the following pattern ",(0,i.kt)("inlineCode",{parentName:"li"},"name: value"),", arguments are sperated by commas also. for example ",(0,i.kt)("inlineCode",{parentName:"li"},"(name: 'frost',year:2022)"),". Position is not important so ",(0,i.kt)("inlineCode",{parentName:"li"},"(name: 'frost',year:2022)")," is the same as ",(0,i.kt)("inlineCode",{parentName:"li"},"(year:2022, name: 'frost')"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("em",{parentName:"strong"},"Both Types of Arguments")),":",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Position of the named arguments is not relevant they can be at the begining or the end or scatterd between the parenthesis."),(0,i.kt)("li",{parentName:"ul"},"Position of the Positional arguments is determined relative to the occurence of the specific argument, so a third positional argument could be number 5 in the parenthesis given that there are two named arguments before it.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"for example: ",(0,i.kt)("inlineCode",{parentName:"li"},"('first_pos_arg','second_pos_arg',a:1,b:2,'third_pos_arg')"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"the arguments map will be as follows:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"args[0] = 'first_pos_arg'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"args[1] = 'second_pos_arg'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"args[2] = 'third_pos_arg'")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"args['a'] = 1")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"args['b] = 2"))))))))))),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"Even though frost allows the user to mix the position in the arguments, The user should follow a structure to avoid confusion.\nRecommend Structure: to write all the posiotional arguments first then the named arguments, this way it's easy to determine the position of the positional arguments.")),(0,i.kt)("h4",{id:"primitive-values"},"Primitive Values"),(0,i.kt)("p",null,"FSL allows three types of primitive values to be used in arguments, pragmas, modifiers, and definitions. These three types are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Boolean: ","[",(0,i.kt)("inlineCode",{parentName:"li"},"true"),",",(0,i.kt)("inlineCode",{parentName:"li"},"false"),"]",". (case sensitive)."),(0,i.kt)("li",{parentName:"ul"},"Numbers:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Integers: examples(",(0,i.kt)("inlineCode",{parentName:"li"},"1"),",",(0,i.kt)("inlineCode",{parentName:"li"},"20"),")"),(0,i.kt)("li",{parentName:"ul"},"Decimal (floats): examples(",(0,i.kt)("inlineCode",{parentName:"li"},"1.0"),",",(0,i.kt)("inlineCode",{parentName:"li"},"20.2"),")"),(0,i.kt)("li",{parentName:"ul"},"Negative: examples(",(0,i.kt)("inlineCode",{parentName:"li"},"-1.0"),",",(0,i.kt)("inlineCode",{parentName:"li"},"-20"),")"))),(0,i.kt)("li",{parentName:"ul"},"Strings:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"single quotation: example(",(0,i.kt)("inlineCode",{parentName:"li"},"'name'"),")"),(0,i.kt)("li",{parentName:"ul"},"double quotation: example(",(0,i.kt)("inlineCode",{parentName:"li"},'"name"'),")"),(0,i.kt)("li",{parentName:"ul"},"backtick quotation: example(",(0,i.kt)("inlineCode",{parentName:"li"},"`name`"),")")))),(0,i.kt)("h4",{id:"allowed-data-types"},"Allowed Data types"),(0,i.kt)("p",null,"Data Types will be used to define the type of properties in ",(0,i.kt)("a",{parentName:"p",href:"#defining-models"},"Models")," and ",(0,i.kt)("a",{parentName:"p",href:"#defining-types"},"Types"),"."),(0,i.kt)("p",null,"The Allowed Data Types are:"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"FSL"),(0,i.kt)("th",{parentName:"tr",align:null},"Typescript/Javascript"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"String"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"string"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Boolean"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"boolean"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Double, Float, Decimal, Long, Short"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"number"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Date"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"Date"))),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Json"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"any"))))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Also, Any ",(0,i.kt)("a",{parentName:"li",href:"#defining-enums"},"Enum")," or ",(0,i.kt)("a",{parentName:"li",href:"#defining-types"},"Type")," that have been already defined can be used as the type of the property."),(0,i.kt)("li",{parentName:"ul"},"Inside ",(0,i.kt)("a",{parentName:"li",href:"#defining-models"},"Model Relations Definitions"),", Other Models Could be used as Data types."),(0,i.kt)("li",{parentName:"ul"},"All these types can be used as arrays by adding ",(0,i.kt)("inlineCode",{parentName:"li"},"[]"),",  Eaxmple: ",(0,i.kt)("inlineCode",{parentName:"li"},"String[]")),(0,i.kt)("li",{parentName:"ul"},"All these types can be marked as optional using ",(0,i.kt)("inlineCode",{parentName:"li"},"?"),", Eaxmples: ",(0,i.kt)("inlineCode",{parentName:"li"},"String?"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"String[]?")),(0,i.kt)("li",{parentName:"ul"},"Map/Record: ",(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("em",{parentName:"strong"},"Coming soon"))," use json type instead or define a specific ",(0,i.kt)("a",{parentName:"li",href:"#defining-types"},"type"))),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"All types are case insensitive except for user-defined types and enums.")),(0,i.kt)("h3",{id:"defintions"},"Defintions"),(0,i.kt)("p",null,"There are types of definitions in FSL ","[",(0,i.kt)("inlineCode",{parentName:"p"},"model"),",",(0,i.kt)("inlineCode",{parentName:"p"},"enum"),",",(0,i.kt)("inlineCode",{parentName:"p"},"type"),"]",". each definition starts with the declartion statement then followed by a block of statements\n(assignment statements in ",(0,i.kt)("inlineCode",{parentName:"p"},"enum")," block, and property declartion statements in ",(0,i.kt)("inlineCode",{parentName:"p"},"type")," an ",(0,i.kt)("inlineCode",{parentName:"p"},"model"),")"),(0,i.kt)("p",null,"Each Definition follows the following pattern"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-prisma"},"<definition_type> <instance_name> {\n  <statements>\n}\n")),(0,i.kt)("p",null,"for example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-prisma"},"enum Name {\n  FIRST\n  MIDDLE\n  LAST\n}\n")),(0,i.kt)("h4",{id:"defining-enums"},"Defining Enums"),(0,i.kt)("p",null,"Enums in FSL, follow the same style of enums in Typescript.\nTo declare the enum:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"write down ",(0,i.kt)("inlineCode",{parentName:"li"},"enum <enum_name> ")," and follow with a block of code by opening two curly brackets ",(0,i.kt)("inlineCode",{parentName:"li"},"{}")),(0,i.kt)("li",{parentName:"ul"},"Between the two curly brackets, define the enum values using assignment statements.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"each statement follows the pattern ",(0,i.kt)("inlineCode",{parentName:"li"},"<name> = <value>"),", so something like ",(0,i.kt)("inlineCode",{parentName:"li"},"A = 'a'")),(0,i.kt)("li",{parentName:"ul"},"If the value is not provided, it defaults to the typical behaviour of Typescript. ie; the enum value will be the integer representing the position stating from zero.")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-prisma"},"enum Character {\n  A\n  B\n  C\n  ...\n}\n\n//The Above is equivalent to\nenum Character {\n  A = 0\n  B = 1\n  C = 2\n  ...\n}\n")),(0,i.kt)("p",null,"The value of the enum values could be any of the ",(0,i.kt)("a",{parentName:"p",href:"#primitive-values"},"primitives"),", so you could something like:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-prisma"},"enum Character {\n  A = 'a'\n  B = 'b'\n  C = 'c'\n  ...\n}\n\n// or even something mixed like\nenum Character {\n  A = 'a'\n  B = 2\n  C = true\n  D\n  ...\n}\n\n")),(0,i.kt)("h4",{id:"defining-types"},"Defining Types"),(0,i.kt)("p",null,"Types in FSL are like types in Typescript, the represent data interfaces.\nto declare a type:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"write down ",(0,i.kt)("inlineCode",{parentName:"li"},"type <type_name> ")," and follow with a block of code by opening two curly brackets ",(0,i.kt)("inlineCode",{parentName:"li"},"{}")),(0,i.kt)("li",{parentName:"ul"},"Between the two curly brackets, define the properties with the pattern ",(0,i.kt)("inlineCode",{parentName:"li"},"<property_name> <property_type>"),", property_type should follow mentioned above in ",(0,i.kt)("a",{parentName:"li",href:"#allowed-data-types"},'"Allowed Data types"')," section. ")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-prisma"},"type Name {\n  first_name String\n  middle_name String? // This an optional property\n  last_name String\n}\n\n// another example \n\ntype ContactInfo {\n  name Name // this uses the type defined above\n  email String // this is a primitive string\n  initials Character[]? // this uses the enum defined in the previous section and it's an array and also optional\n}\n")),(0,i.kt)("h4",{id:"defining-models"},"Defining Models"),(0,i.kt)("p",null,"Models in FSL represent the sturcture of the data objects in a certain node in the database.\nThe syntax for defining a model is very similar for defining a Type except for a few differences."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Of course you will use the keyword ",(0,i.kt)("inlineCode",{parentName:"li"},"model")," instead of ",(0,i.kt)("inlineCode",{parentName:"li"},"type")," at the begining of the declaration."),(0,i.kt)("li",{parentName:"ul"},"Property definition statements in the model can accept the ",(0,i.kt)("a",{parentName:"li",href:"#relation-modifier"},(0,i.kt)("inlineCode",{parentName:"a"},"Relation")," modifier"),".",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Other models can be used as data types in the model properties declaration, and actually you will have to use them if you want to decalre a relation between two models"))),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("a",{parentName:"li",href:"#node-pragma"},"`node`` pragma")," can be used in the model definition block.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-prisma"},"model Student {\n\n  // the students list will be stored in te following path in the database /students/<student_id>\n  @@node(path:'students') \n\n  contactInfo ContactInfo // this uses the data type defined in the previous section\n  dateOfBirth Date // Native Date type\n\n  courses Courses[] @Relation() \n  // this property is used to define a relation with the Course model, since the data type is model.\n  // you will find a corresponding property in the Course model\n  // Since properties on both side are array types then the relation is `many to many`\n\n}\n\nmodel Course {\n\n  // the courses list will be stored in te following path in the database /courses/<course_id>\n  @@node(path:'courses') \n\n  level CourseLevel // a user-defined enum\n  name String\n  duration Int\n\n  students Student[] @Relation()\n}\n")),(0,i.kt)("h5",{id:"node-pragma"},(0,i.kt)("inlineCode",{parentName:"h5"},"node")," Pragma"),(0,i.kt)("p",null,"The node pragma is used to add any extra metadata for the node model. As of right now the only option available inside the node pragma is the ",(0,i.kt)("inlineCode",{parentName:"p"},"path"),".\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"path")," argument is used to determine the path of the node in the firebaseDB that will contain the list of the model nodes. if the node pragma is not used the path will default to the same name of the model."),(0,i.kt)("h5",{id:"relation-modifier"},(0,i.kt)("inlineCode",{parentName:"h5"},"Relation")," Modifier"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Relation")," Modifier is used to mark which properties have relations with other Models.\nBy default the Relation modifier requires no arguments, But if you have multiple relations between the same models then you have to specify the name of the relation using the ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," argument."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The Type of the relation is determined from the Data type of the property."),(0,i.kt)("ul",{parentName:"admonition"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("em",{parentName:"strong"},"Many To Many")),": if both sides are arrays"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("em",{parentName:"strong"},"One To Many")),": if one side is an array and the other is not."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("em",{parentName:"strong"},"One To One")),": if both sides are not arrays"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-prisma"},'model A {\n ...\n\n b1 B  @Relation()\n b2 B  @Relation(name: "A_B_second")\n}\n\nmodel B {\n\na1 A @Relation()\na2 A @Relation(name: "A_B_second")\n\n}\n')),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"You don't have to specify the name for the first relation between ",(0,i.kt)("inlineCode",{parentName:"p"},"b1")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"a1"),",\nbut you could if you want to make it less ambigous. you could put ",(0,i.kt)("inlineCode",{parentName:"p"},'name: "A_B_first"')," between the parenthesis ",(0,i.kt)("inlineCode",{parentName:"p"},'@Relation(name: "A_B_first")')," on both sides")),(0,i.kt)("h2",{id:"syntax-highlighting"},"Syntax Highlighting"),(0,i.kt)("h3",{id:"vscode"},"Vscode"),(0,i.kt)("p",null,"An Extension for Syntax Highlighting FSL in VScode was created. You can find it ",(0,i.kt)("a",{parentName:"p",href:"https://marketplace.visualstudio.com/items?itemName=frost-orm.frost-schema-syntax-highlighting"},"here")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Vscode syntax Highlight Example 01",src:n(2560).Z,width:"853",height:"1167"}),"\n",(0,i.kt)("img",{alt:"Vscode syntax Highlight Example 02",src:n(3213).Z,width:"853",height:"1167"})))}p.isMDXComponent=!0},2560:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/01-28f66df6b4b253b8873861be97a5b746.png"},3213:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/02-f9b6191e5f066d82528f298b04417a84.png"}}]);